<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java基础</title>
    <url>/2020/04/19/aaa/</url>
    <content><![CDATA[<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul>
<li><p>面向过程</p>
<ul>
<li>面向过程的性能更高。因为面向对象类的调用需要实例化，比较消耗资源，</li>
</ul>
</li>
<li><p>面向对象</p>
<ul>
<li>更易维护，易扩展，易复用。面向对象有，封装，继承，多态的特性，可以设计出低耦合的系统，是系统更加灵活，更加易于维护。<a id="more"></a>
<h3 id="java和c-的区别"><a href="#java和c-的区别" class="headerlink" title="java和c++的区别"></a>java和c++的区别</h3></li>
</ul>
</li>
<li><p>都是面向对象的编程语言，都有封装、继承、多态特性</p>
</li>
<li><p>java不提供指针来直接访问内存，程序内存更安全</p>
</li>
<li><p>java类是单继承的，c++是多继承的，但是java的接口是多继承的</p>
</li>
<li><p>java有自动的内存管理机制，不需要程序员手动的释放无用内存</p>
</li>
</ul>
<h3 id="java面向对象的三大特性：封装、继承、多态"><a href="#java面向对象的三大特性：封装、继承、多态" class="headerlink" title="java面向对象的三大特性：封装、继承、多态"></a>java面向对象的三大特性：封装、继承、多态</h3><ul>
<li>封装</li>
<li>继承<ul>
<li>子类继承父类拥有父类的私有方法和属性，但是只是拥有，却无法访问</li>
</ul>
</li>
<li>多态<ul>
<li>在java中只有两种形式能实现多态<ul>
<li>继承：多个子类对同一个父类方法进行重写</li>
<li>接口：实现接口并覆盖接口中的同一方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="StringBuffer-and-stringbuilder-的区别是什么？string为什么是不可变的"><a href="#StringBuffer-and-stringbuilder-的区别是什么？string为什么是不可变的" class="headerlink" title="StringBuffer and stringbuilder 的区别是什么？string为什么是不可变的"></a>StringBuffer and stringbuilder 的区别是什么？string为什么是不可变的</h3><ul>
<li>因为string对象中使用final关键字 修饰 字符数组 来保存字符串</li>
<li>StringBuffer <ul>
<li>线程安全</li>
</ul>
</li>
<li>stringbuilder <ul>
<li>线程不安全</li>
<li>性能比buffer高10%-15%</li>
</ul>
</li>
</ul>
<h3 id="在java中定义一个不做事且没有参数的构造方法的作用"><a href="#在java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在java中定义一个不做事且没有参数的构造方法的作用"></a>在java中定义一个不做事且没有参数的构造方法的作用</h3><ul>
<li>子类没有通过super调用父类构造器，就会调用父类无参构造器，若没有报错</li>
</ul>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是对行为的抽象，是一种行为的规范。</li>
<li>一个类可以实现多个接口，但是只能实现一个抽象类</li>
<li>接口方法默认修饰符是public，但是抽象类可以有public、protected 和 default，因为抽象类的方法就是用来被重写的所以不能用private。</li>
<li>接口中在jdk1.8之前不能有方法的实现，而抽象类可以有非抽象方法   </li>
</ul>
<h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ul>
<li>从语法形式上看<ul>
<li>成员变量是属于类的<ul>
<li>可以被修饰符修饰</li>
</ul>
</li>
<li>局部变量是在方法中定义的变量或是方法的参数<ul>
<li>不可以被访问控制修饰符及static修饰</li>
</ul>
</li>
<li>都可以被final修饰</li>
</ul>
</li>
<li>从在内存中的存储方式上看<ul>
<li>对象存在堆内存<ul>
<li>如果成员变量是使用static修饰的那么是属于类的</li>
<li>否则是属于实例的</li>
</ul>
</li>
<li>局部变量存在栈内存</li>
</ul>
</li>
<li>从在内存中的生存时间上看<ul>
<li>成员变量是对象中的一部分，他随着对象的创建而存在</li>
<li>而局部变量随着方法的调用而消失。</li>
</ul>
</li>
<li>如果没有被赋予初始值<ul>
<li>成员变量会自动被赋予类型的默认值<ul>
<li>被final修饰的成员变量需要显式赋值</li>
</ul>
</li>
<li>局部变量不会</li>
</ul>
</li>
</ul>
<h3 id="对象实体与对象有什么区别"><a href="#对象实体与对象有什么区别" class="headerlink" title="对象实体与对象有什么区别"></a>对象实体与对象有什么区别</h3><ul>
<li>通过new运算符创建对象</li>
<li>对象实例存放在堆中<ul>
<li>对象实例可以被多个引用所指</li>
</ul>
</li>
<li>对象引用存放在栈中<ul>
<li>对象引用指向对象实例</li>
<li>对象引用只能指向一个或0个实例</li>
</ul>
</li>
</ul>
<h3 id="静态方法和实例方法有什么不同"><a href="#静态方法和实例方法有什么不同" class="headerlink" title="静态方法和实例方法有什么不同"></a>静态方法和实例方法有什么不同</h3><ul>
<li>静态方法可以不通过实例化就可以调用</li>
<li>静态方法在访问本类成员时只能访问静态成员（静态方法，静态成员变量）</li>
</ul>
<h3 id="对象的相等与指向他们的引用的相等有什么不同"><a href="#对象的相等与指向他们的引用的相等有什么不同" class="headerlink" title="对象的相等与指向他们的引用的相等有什么不同"></a>对象的相等与指向他们的引用的相等有什么不同</h3><ul>
<li>对象的相等是，内存中存放的内容是否相等</li>
<li>指向他们的引用的相等是，他们是否指向同一个内存地址</li>
</ul>
<h3 id="在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法-其⽬的是"><a href="#在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法-其⽬的是" class="headerlink" title="在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法,其⽬的是?"></a>在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法,其⽬的是?</h3><ul>
<li>帮助子类做初始化工作</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Love</title>
    <url>/2020/04/19/s/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="您好, 这里需要密码." /><label>您好, 这里需要密码.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="00acf256cee0fb7f1c87d90e8680f8a8a1d073df689d2c16f18794865183717d">bdeda12f88ab709b4f26c88d4b192778</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础</title>
    <url>/2020/05/12/js%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><p>​    是浅拷贝还是深拷贝?</p>
<p>​        首先，我们要说的是Object.assign的基本用法：</p>
<p>​        Object.assign(目标,数据1,数据2….);<u></u></p>
<a id="more"></a>

<p>​    示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj) <span class="comment">//&#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj1,obj2);</span><br><span class="line"><span class="built_in">console</span>.log(obj3) <span class="comment">//&#123;name: "zhangsan", age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>​    关于Object.assign是浅拷贝还是深拷贝的问题：     </p>
<p>​        <em>答：第一级属性深拷贝，从第二级属性开始就是浅拷贝。</em></p>
<p>​    示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1  一层深拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a: 1&#125;</span></span><br><span class="line">newObj.a=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;a:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2  二层浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a:1,b:&#123;name:"zhangsan"&#125;&#125;</span></span><br><span class="line">newObj.b.name=<span class="string">"lisi"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;a:1,b:&#123;name:"lisi"&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a:1,b:&#123;name:"lisi"&#125;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>KOUKOU专属</tag>
      </tags>
  </entry>
  <entry>
    <title>博客</title>
    <url>/2020/05/19/%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="如何创建博客"><a href="#如何创建博客" class="headerlink" title="如何创建博客"></a>如何创建博客</h3><ol>
<li>hexo new 文件名</li>
<li>hexo clean 清理huancun</li>
<li>hexo g重新生成</li>
<li>hexo d上传github page<ol>
<li>安装插件 —— npm install hexo-deployer-git –save</li>
<li>hexo d上传</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
</search>
