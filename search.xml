<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java基础</title>
    <url>/2020/04/19/aaa/</url>
    <content><![CDATA[<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul>
<li><p>面向过程</p>
<ul>
<li>面向过程的性能更高。因为面向对象类的调用需要实例化，比较消耗资源，</li>
</ul>
</li>
<li><p>面向对象</p>
<ul>
<li>更易维护，易扩展，易复用。面向对象有，封装，继承，多态的特性，可以设计出低耦合的系统，是系统更加灵活，更加易于维护。<a id="more"></a>
<h3 id="java和c-的区别"><a href="#java和c-的区别" class="headerlink" title="java和c++的区别"></a>java和c++的区别</h3></li>
</ul>
</li>
<li><p>都是面向对象的编程语言，都有封装、继承、多态特性</p>
</li>
<li><p>java不提供指针来直接访问内存，程序内存更安全</p>
</li>
<li><p>java类是单继承的，c++是多继承的，但是java的接口是多继承的</p>
</li>
<li><p>java有自动的内存管理机制，不需要程序员手动的释放无用内存</p>
</li>
</ul>
<h3 id="java面向对象的三大特性：封装、继承、多态"><a href="#java面向对象的三大特性：封装、继承、多态" class="headerlink" title="java面向对象的三大特性：封装、继承、多态"></a>java面向对象的三大特性：封装、继承、多态</h3><ul>
<li>封装</li>
<li>继承<ul>
<li>子类继承父类拥有父类的私有方法和属性，但是只是拥有，却无法访问</li>
</ul>
</li>
<li>多态<ul>
<li>在java中只有两种形式能实现多态<ul>
<li>继承：多个子类对同一个父类方法进行重写</li>
<li>接口：实现接口并覆盖接口中的同一方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="StringBuffer-and-stringbuilder-的区别是什么？string为什么是不可变的"><a href="#StringBuffer-and-stringbuilder-的区别是什么？string为什么是不可变的" class="headerlink" title="StringBuffer and stringbuilder 的区别是什么？string为什么是不可变的"></a>StringBuffer and stringbuilder 的区别是什么？string为什么是不可变的</h3><ul>
<li>因为string对象中使用final关键字 修饰 字符数组 来保存字符串</li>
<li>StringBuffer <ul>
<li>线程安全</li>
</ul>
</li>
<li>stringbuilder <ul>
<li>线程不安全</li>
<li>性能比buffer高10%-15%</li>
</ul>
</li>
</ul>
<h3 id="在java中定义一个不做事且没有参数的构造方法的作用"><a href="#在java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在java中定义一个不做事且没有参数的构造方法的作用"></a>在java中定义一个不做事且没有参数的构造方法的作用</h3><ul>
<li>子类没有通过super调用父类构造器，就会调用父类无参构造器，若没有报错</li>
</ul>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是对行为的抽象，是一种行为的规范。</li>
<li>一个类可以实现多个接口，但是只能实现一个抽象类</li>
<li>接口方法默认修饰符是public，但是抽象类可以有public、protected 和 default，因为抽象类的方法就是用来被重写的所以不能用private。</li>
<li>接口中在jdk1.8之前不能有方法的实现，而抽象类可以有非抽象方法   </li>
</ul>
<h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ul>
<li>从语法形式上看<ul>
<li>成员变量是属于类的<ul>
<li>可以被修饰符修饰</li>
</ul>
</li>
<li>局部变量是在方法中定义的变量或是方法的参数<ul>
<li>不可以被访问控制修饰符及static修饰</li>
</ul>
</li>
<li>都可以被final修饰</li>
</ul>
</li>
<li>从在内存中的存储方式上看<ul>
<li>对象存在堆内存<ul>
<li>如果成员变量是使用static修饰的那么是属于类的</li>
<li>否则是属于实例的</li>
</ul>
</li>
<li>局部变量存在栈内存</li>
</ul>
</li>
<li>从在内存中的生存时间上看<ul>
<li>成员变量是对象中的一部分，他随着对象的创建而存在</li>
<li>而局部变量随着方法的调用而消失。</li>
</ul>
</li>
<li>如果没有被赋予初始值<ul>
<li>成员变量会自动被赋予类型的默认值<ul>
<li>被final修饰的成员变量需要显式赋值</li>
</ul>
</li>
<li>局部变量不会</li>
</ul>
</li>
</ul>
<h3 id="对象实体与对象有什么区别"><a href="#对象实体与对象有什么区别" class="headerlink" title="对象实体与对象有什么区别"></a>对象实体与对象有什么区别</h3><ul>
<li>通过new运算符创建对象</li>
<li>对象实例存放在堆中<ul>
<li>对象实例可以被多个引用所指</li>
</ul>
</li>
<li>对象引用存放在栈中<ul>
<li>对象引用指向对象实例</li>
<li>对象引用只能指向一个或0个实例</li>
</ul>
</li>
</ul>
<h3 id="静态方法和实例方法有什么不同"><a href="#静态方法和实例方法有什么不同" class="headerlink" title="静态方法和实例方法有什么不同"></a>静态方法和实例方法有什么不同</h3><ul>
<li>静态方法可以不通过实例化就可以调用</li>
<li>静态方法在访问本类成员时只能访问静态成员（静态方法，静态成员变量）</li>
</ul>
<h3 id="对象的相等与指向他们的引用的相等有什么不同"><a href="#对象的相等与指向他们的引用的相等有什么不同" class="headerlink" title="对象的相等与指向他们的引用的相等有什么不同"></a>对象的相等与指向他们的引用的相等有什么不同</h3><ul>
<li>对象的相等是，内存中存放的内容是否相等</li>
<li>指向他们的引用的相等是，他们是否指向同一个内存地址</li>
</ul>
<h3 id="在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法-其⽬的是"><a href="#在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法-其⽬的是" class="headerlink" title="在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法,其⽬的是?"></a>在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法,其⽬的是?</h3><ul>
<li>帮助子类做初始化工作</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>GUGU</category>
        <category>java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础</title>
    <url>/2020/05/12/js%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><p>​    是浅拷贝还是深拷贝?</p>
<p>​        首先，我们要说的是Object.assign的基本用法：</p>
<p>​        Object.assign(目标,数据1,数据2….);<u></u></p>
<a id="more"></a>

<p>​    示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj) <span class="comment">//&#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj1,obj2);</span><br><span class="line"><span class="built_in">console</span>.log(obj3) <span class="comment">//&#123;name: "zhangsan", age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>​    关于Object.assign是浅拷贝还是深拷贝的问题：     </p>
<p>​        <em>答：第一级属性深拷贝，从第二级属性开始就是浅拷贝。</em></p>
<p>​    示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1  一层深拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a: 1&#125;</span></span><br><span class="line">newObj.a=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;a:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2  二层浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a:1,b:&#123;name:"zhangsan"&#125;&#125;</span></span><br><span class="line">newObj.b.name=<span class="string">"lisi"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;a:1,b:&#123;name:"lisi"&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a:1,b:&#123;name:"lisi"&#125;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>基础</category>
        <category>KOUKOU</category>
      </categories>
      <tags>
        <tag>KOUKOU专属</tag>
      </tags>
  </entry>
  <entry>
    <title>Love</title>
    <url>/2020/04/19/s/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="您好, 这里需要密码." /><label>您好, 这里需要密码.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="00acf256cee0fb7f1c87d90e8680f8a8a1d073df689d2c16f18794865183717d">bdeda12f88ab709b4f26c88d4b192778</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>博客</title>
    <url>/2020/05/19/%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="如何创建博客"><a href="#如何创建博客" class="headerlink" title="如何创建博客"></a>如何创建博客</h3><ol>
<li>hexo new 文件名</li>
<li>hexo clean 清理huancun</li>
<li>hexo g重新生成</li>
<li>hexo d上传github page<ol>
<li>安装插件 —— npm install hexo-deployer-git –save</li>
<li>hexo d上传</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>GUGU</category>
      </categories>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理之概述篇</title>
    <url>/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/</url>
    <content><![CDATA[<h2 id="计算机组成原理之概述篇"><a href="#计算机组成原理之概述篇" class="headerlink" title="计算机组成原理之概述篇"></a>计算机组成原理之概述篇</h2><h3 id="计算机的发展简史"><a href="#计算机的发展简史" class="headerlink" title="计算机的发展简史"></a>计算机的发展简史</h3><ul>
<li>四个阶段<ol>
<li>电子管</li>
<li>晶体管</li>
<li>集成电路（IC）<ul>
<li>在该阶段产生了操作系统</li>
</ul>
</li>
<li>超大规模集成电路<a id="more"></a>
<h3 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h3></li>
</ol>
</li>
</ul>
<ol>
<li>超级计算机</li>
<li>大型计算机</li>
<li>迷你计算机（服务器）</li>
<li>工作站（做视频，画图 – 超高性能）</li>
<li>微型计算机（个人计算机）</li>
</ol>
<h3 id="计算机的体系结构"><a href="#计算机的体系结构" class="headerlink" title="计算机的体系结构"></a>计算机的体系结构</h3><h4 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h4><ul>
<li>思想：存储程序指令，设计通用电路</li>
</ul>
<img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/1.jpg" class title="计算机的体系与结构">

<h5 id="冯诺依曼瓶颈"><a href="#冯诺依曼瓶颈" class="headerlink" title="冯诺依曼瓶颈"></a>冯诺依曼瓶颈</h5><ul>
<li>问题：存储器的速率跟不上CPU的运行效率</li>
<li>表现：CPU经常空转，等到存储器的数据传输<ul>
<li>CPU空转：CPU通电后就会一直运转，一直执行指令，若无指令就原地旋转。<ul>
<li>多核CPU：至少有一个CPU不会停止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h4><ul>
<li>解决了冯诺依曼瓶颈</li>
</ul>
<img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/2.jpg" class>

<h3 id="计算机层次与编程语言"><a href="#计算机层次与编程语言" class="headerlink" title="计算机层次与编程语言"></a>计算机层次与编程语言</h3><h4 id="程序编译与程序解释"><a href="#程序编译与程序解释" class="headerlink" title="程序编译与程序解释"></a>程序编译与程序解释</h4><h5 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h5><img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/3.jpg" class>

<h5 id="程序解释"><a href="#程序解释" class="headerlink" title="程序解释"></a>程序解释</h5><img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/4.jpg" class>

<h5 id="程序编译与程序解释的区别"><a href="#程序编译与程序解释的区别" class="headerlink" title="程序编译与程序解释的区别"></a>程序编译与程序解释的区别</h5><ul>
<li><p>编译的时候编译器会把源文件处理一遍，生成一个目标文件，而解释就是边处理源文件边执行。</p>
</li>
<li><p>编译相当于做好一桌子菜再开吃，解释就是吃火锅，得一边煮一边吃，所以解释执行效率会低一些。</p>
</li>
</ul>
<h4 id="计算机得层次"><a href="#计算机得层次" class="headerlink" title="计算机得层次"></a>计算机得层次</h4><img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/6.jpg" class>

<ul>
<li>硬件逻辑层<ul>
<li>属于电子工程邻域</li>
</ul>
</li>
<li>微程序逻辑层<ul>
<li>编程语言：微指令集</li>
<li>微指令所组成得微程序直接交由硬件执行</li>
</ul>
</li>
<li>传统机器层<ul>
<li>编程语言：CPU指令（机器指令）</li>
<li>不同架构得CPU使用不同得CPU指令集</li>
</ul>
</li>
</ul>
<blockquote>
<p>一条 机器指令 对应 一个 微程序<br>一个 微程序 对应 一组 微指令</p>
</blockquote>
<ul>
<li>操作系统层</li>
<li>汇编语言层</li>
</ul>
<h3 id="计算机单位"><a href="#计算机单位" class="headerlink" title="计算机单位"></a>计算机单位</h3><h4 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a>容量单位</h4><img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/5.png" class>

<ul>
<li>在物理层面，记录高低电平的信息</li>
<li>理论上只认识0/1两种状态</li>
<li>0/1称为bit</li>
</ul>
<blockquote>
<p>为什么网上买的500GB移动硬盘，格式化后只有465GB</p>
<ul>
<li>因为硬盘商一般用10进制标记容量</li>
<li>500 * 1000的3次方 / 1024的3次方 = 465</li>
</ul>
</blockquote>
<h4 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a>速度单位</h4><h5 id="网络速度"><a href="#网络速度" class="headerlink" title="网络速度"></a>网络速度</h5><ul>
<li>网络速度单位为 M比特每秒</li>
<li>容量单位为M字节</li>
</ul>
<blockquote>
<p>为什么电信拉的100M光纤，测试峰值速度只有12M每秒？</p>
<ul>
<li>网络常用单位为Mbps</li>
<li>100M/s=100Mbps=100Mbit/s=（100/8）MB/s=12.5MB/s</li>
</ul>
</blockquote>
<h5 id="CPU速度"><a href="#CPU速度" class="headerlink" title="CPU速度"></a>CPU速度</h5><ul>
<li>单位HZ</li>
<li>CPU赫兹描述的是<ul>
<li>高低电平每秒变化的次数</li>
</ul>
</li>
</ul>
<h3 id="计算机的字符编码集"><a href="#计算机的字符编码集" class="headerlink" title="计算机的字符编码集"></a>计算机的字符编码集</h3><ul>
<li>国际 ASCII</li>
<li>中国<ul>
<li>GB2312 -&gt;  GBK  -&gt; unicode </li>
</ul>
</li>
<li>unicode可表达世界上所有的语言</li>
<li>Windows默认使用GBK编码格式</li>
</ul>
]]></content>
      <categories>
        <category>GUGU</category>
        <category>KOUKOU</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
