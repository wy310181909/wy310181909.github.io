<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Love</title>
    <url>/2020/04/19/s/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容."><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="您好, 这里需要密码." /><label>您好, 这里需要密码.</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="00acf256cee0fb7f1c87d90e8680f8a8a1d073df689d2c16f18794865183717d">bdeda12f88ab709b4f26c88d4b192778</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>Love</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/2020/04/19/aaa/</url>
    <content><![CDATA[<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul>
<li><p>面向过程</p>
<ul>
<li>面向过程的性能更高。因为面向对象类的调用需要实例化，比较消耗资源，</li>
</ul>
</li>
<li><p>面向对象</p>
<ul>
<li>更易维护，易扩展，易复用。面向对象有，封装，继承，多态的特性，可以设计出低耦合的系统，是系统更加灵活，更加易于维护。<a id="more"></a>
<h3 id="java和c-的区别"><a href="#java和c-的区别" class="headerlink" title="java和c++的区别"></a>java和c++的区别</h3></li>
</ul>
</li>
<li><p>都是面向对象的编程语言，都有封装、继承、多态特性</p>
</li>
<li><p>java不提供指针来直接访问内存，程序内存更安全</p>
</li>
<li><p>java类是单继承的，c++是多继承的，但是java的接口是多继承的</p>
</li>
<li><p>java有自动的内存管理机制，不需要程序员手动的释放无用内存</p>
</li>
</ul>
<h3 id="java面向对象的三大特性：封装、继承、多态"><a href="#java面向对象的三大特性：封装、继承、多态" class="headerlink" title="java面向对象的三大特性：封装、继承、多态"></a>java面向对象的三大特性：封装、继承、多态</h3><ul>
<li>封装</li>
<li>继承<ul>
<li>子类继承父类拥有父类的私有方法和属性，但是只是拥有，却无法访问</li>
</ul>
</li>
<li>多态<ul>
<li>在java中只有两种形式能实现多态<ul>
<li>继承：多个子类对同一个父类方法进行重写</li>
<li>接口：实现接口并覆盖接口中的同一方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="StringBuffer-and-stringbuilder-的区别是什么？string为什么是不可变的"><a href="#StringBuffer-and-stringbuilder-的区别是什么？string为什么是不可变的" class="headerlink" title="StringBuffer and stringbuilder 的区别是什么？string为什么是不可变的"></a>StringBuffer and stringbuilder 的区别是什么？string为什么是不可变的</h3><ul>
<li>因为string对象中使用final关键字 修饰 字符数组 来保存字符串</li>
<li>StringBuffer <ul>
<li>线程安全</li>
</ul>
</li>
<li>stringbuilder <ul>
<li>线程不安全</li>
<li>性能比buffer高10%-15%</li>
</ul>
</li>
</ul>
<h3 id="在java中定义一个不做事且没有参数的构造方法的作用"><a href="#在java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在java中定义一个不做事且没有参数的构造方法的作用"></a>在java中定义一个不做事且没有参数的构造方法的作用</h3><ul>
<li>子类没有通过super调用父类构造器，就会调用父类无参构造器，若没有报错</li>
</ul>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是对行为的抽象，是一种行为的规范。</li>
<li>一个类可以实现多个接口，但是只能实现一个抽象类</li>
<li>接口方法默认修饰符是public，但是抽象类可以有public、protected 和 default，因为抽象类的方法就是用来被重写的所以不能用private。</li>
<li>接口中在jdk1.8之前不能有方法的实现，而抽象类可以有非抽象方法   </li>
</ul>
<h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ul>
<li>从语法形式上看<ul>
<li>成员变量是属于类的<ul>
<li>可以被修饰符修饰</li>
</ul>
</li>
<li>局部变量是在方法中定义的变量或是方法的参数<ul>
<li>不可以被访问控制修饰符及static修饰</li>
</ul>
</li>
<li>都可以被final修饰</li>
</ul>
</li>
<li>从在内存中的存储方式上看<ul>
<li>对象存在堆内存<ul>
<li>如果成员变量是使用static修饰的那么是属于类的</li>
<li>否则是属于实例的</li>
</ul>
</li>
<li>局部变量存在栈内存</li>
</ul>
</li>
<li>从在内存中的生存时间上看<ul>
<li>成员变量是对象中的一部分，他随着对象的创建而存在</li>
<li>而局部变量随着方法的调用而消失。</li>
</ul>
</li>
<li>如果没有被赋予初始值<ul>
<li>成员变量会自动被赋予类型的默认值<ul>
<li>被final修饰的成员变量需要显式赋值</li>
</ul>
</li>
<li>局部变量不会</li>
</ul>
</li>
</ul>
<h3 id="对象实体与对象有什么区别"><a href="#对象实体与对象有什么区别" class="headerlink" title="对象实体与对象有什么区别"></a>对象实体与对象有什么区别</h3><ul>
<li>通过new运算符创建对象</li>
<li>对象实例存放在堆中<ul>
<li>对象实例可以被多个引用所指</li>
</ul>
</li>
<li>对象引用存放在栈中<ul>
<li>对象引用指向对象实例</li>
<li>对象引用只能指向一个或0个实例</li>
</ul>
</li>
</ul>
<h3 id="静态方法和实例方法有什么不同"><a href="#静态方法和实例方法有什么不同" class="headerlink" title="静态方法和实例方法有什么不同"></a>静态方法和实例方法有什么不同</h3><ul>
<li>静态方法可以不通过实例化就可以调用</li>
<li>静态方法在访问本类成员时只能访问静态成员（静态方法，静态成员变量）</li>
</ul>
<h3 id="对象的相等与指向他们的引用的相等有什么不同"><a href="#对象的相等与指向他们的引用的相等有什么不同" class="headerlink" title="对象的相等与指向他们的引用的相等有什么不同"></a>对象的相等与指向他们的引用的相等有什么不同</h3><ul>
<li>对象的相等是，内存中存放的内容是否相等</li>
<li>指向他们的引用的相等是，他们是否指向同一个内存地址</li>
</ul>
<h3 id="在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法-其⽬的是"><a href="#在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法-其⽬的是" class="headerlink" title="在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法,其⽬的是?"></a>在调⽤⼦类构造⽅法之前会先调⽤⽗类没有参数的构造⽅法,其⽬的是?</h3><ul>
<li>帮助子类做初始化工作</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
        <category>GUGU</category>
        <category>java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理之概述篇</title>
    <url>/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/</url>
    <content><![CDATA[<h2 id="计算机组成原理之概述篇"><a href="#计算机组成原理之概述篇" class="headerlink" title="计算机组成原理之概述篇"></a>计算机组成原理之概述篇</h2><h3 id="计算机的发展简史"><a href="#计算机的发展简史" class="headerlink" title="计算机的发展简史"></a>计算机的发展简史</h3><ul>
<li>四个阶段<ol>
<li>电子管</li>
<li>晶体管</li>
<li>集成电路（IC）<ul>
<li>在该阶段产生了操作系统</li>
</ul>
</li>
<li>超大规模集成电路<a id="more"></a>
<h3 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h3></li>
</ol>
</li>
</ul>
<ol>
<li>超级计算机</li>
<li>大型计算机</li>
<li>迷你计算机（服务器）</li>
<li>工作站（做视频，画图 – 超高性能）</li>
<li>微型计算机（个人计算机）</li>
</ol>
<h3 id="计算机的体系结构"><a href="#计算机的体系结构" class="headerlink" title="计算机的体系结构"></a>计算机的体系结构</h3><h4 id="冯诺依曼体系"><a href="#冯诺依曼体系" class="headerlink" title="冯诺依曼体系"></a>冯诺依曼体系</h4><ul>
<li>思想：存储程序指令，设计通用电路</li>
</ul>
<img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/1.jpg" class title="计算机的体系与结构">

<h5 id="冯诺依曼瓶颈"><a href="#冯诺依曼瓶颈" class="headerlink" title="冯诺依曼瓶颈"></a>冯诺依曼瓶颈</h5><ul>
<li>问题：存储器的速率跟不上CPU的运行效率</li>
<li>表现：CPU经常空转，等到存储器的数据传输<ul>
<li>CPU空转：CPU通电后就会一直运转，一直执行指令，若无指令就原地旋转。<ul>
<li>多核CPU：至少有一个CPU不会停止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h4><ul>
<li>解决了冯诺依曼瓶颈</li>
</ul>
<img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/2.jpg" class>

<h3 id="计算机层次与编程语言"><a href="#计算机层次与编程语言" class="headerlink" title="计算机层次与编程语言"></a>计算机层次与编程语言</h3><h4 id="程序编译与程序解释"><a href="#程序编译与程序解释" class="headerlink" title="程序编译与程序解释"></a>程序编译与程序解释</h4><h5 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h5><img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/3.jpg" class>

<h5 id="程序解释"><a href="#程序解释" class="headerlink" title="程序解释"></a>程序解释</h5><img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/4.jpg" class>

<h5 id="程序编译与程序解释的区别"><a href="#程序编译与程序解释的区别" class="headerlink" title="程序编译与程序解释的区别"></a>程序编译与程序解释的区别</h5><ul>
<li><p>编译的时候编译器会把源文件处理一遍，生成一个目标文件，而解释就是边处理源文件边执行。</p>
</li>
<li><p>编译相当于做好一桌子菜再开吃，解释就是吃火锅，得一边煮一边吃，所以解释执行效率会低一些。</p>
</li>
</ul>
<h4 id="计算机得层次"><a href="#计算机得层次" class="headerlink" title="计算机得层次"></a>计算机得层次</h4><img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/6.jpg" class>

<ul>
<li>硬件逻辑层<ul>
<li>属于电子工程邻域</li>
</ul>
</li>
<li>微程序逻辑层<ul>
<li>编程语言：微指令集</li>
<li>微指令所组成得微程序直接交由硬件执行</li>
</ul>
</li>
<li>传统机器层<ul>
<li>编程语言：CPU指令（机器指令）</li>
<li>不同架构得CPU使用不同得CPU指令集</li>
</ul>
</li>
</ul>
<blockquote>
<p>一条 机器指令 对应 一个 微程序<br>一个 微程序 对应 一组 微指令</p>
</blockquote>
<ul>
<li>操作系统层</li>
<li>汇编语言层</li>
</ul>
<h3 id="计算机单位"><a href="#计算机单位" class="headerlink" title="计算机单位"></a>计算机单位</h3><h4 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a>容量单位</h4><img src="/2020/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/5.png" class>

<ul>
<li>在物理层面，记录高低电平的信息</li>
<li>理论上只认识0/1两种状态</li>
<li>0/1称为bit</li>
</ul>
<blockquote>
<p>为什么网上买的500GB移动硬盘，格式化后只有465GB</p>
<ul>
<li>因为硬盘商一般用10进制标记容量</li>
<li>500 * 1000的3次方 / 1024的3次方 = 465</li>
</ul>
</blockquote>
<h4 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a>速度单位</h4><h5 id="网络速度"><a href="#网络速度" class="headerlink" title="网络速度"></a>网络速度</h5><ul>
<li>网络速度单位为 M比特每秒</li>
<li>容量单位为M字节</li>
</ul>
<blockquote>
<p>为什么电信拉的100M光纤，测试峰值速度只有12M每秒？</p>
<ul>
<li>网络常用单位为Mbps</li>
<li>100M/s=100Mbps=100Mbit/s=（100/8）MB/s=12.5MB/s</li>
</ul>
</blockquote>
<h5 id="CPU速度"><a href="#CPU速度" class="headerlink" title="CPU速度"></a>CPU速度</h5><ul>
<li>单位HZ</li>
<li>CPU赫兹描述的是<ul>
<li>高低电平每秒变化的次数</li>
</ul>
</li>
</ul>
<h3 id="计算机的字符编码集"><a href="#计算机的字符编码集" class="headerlink" title="计算机的字符编码集"></a>计算机的字符编码集</h3><ul>
<li>国际 ASCII</li>
<li>中国<ul>
<li>GB2312 -&gt;  GBK  -&gt; unicode </li>
</ul>
</li>
<li>unicode可表达世界上所有的语言</li>
<li>Windows默认使用GBK编码格式</li>
</ul>
]]></content>
      <categories>
        <category>GUGU</category>
        <category>KOUKOU</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络之概述篇</title>
    <url>/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/</url>
    <content><![CDATA[<h3 id="计算机网络的发展简史"><a href="#计算机网络的发展简史" class="headerlink" title="计算机网络的发展简史"></a>计算机网络的发展简史</h3><h4 id="互联网的发展历史"><a href="#互联网的发展历史" class="headerlink" title="互联网的发展历史"></a>互联网的发展历史</h4><ol>
<li>第一阶段：单个网络ARPANET<a id="more"></a></li>
<li>第二阶段：三层结构互联网<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/1.png" class></li>
<li>第三阶段：多层次ISP互联网<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/2.png" class>

</li>
</ol>
<h3 id="计算机网络的层次结构"><a href="#计算机网络的层次结构" class="headerlink" title="计算机网络的层次结构"></a>计算机网络的层次结构</h3><h4 id="层次结构设计的基本原则"><a href="#层次结构设计的基本原则" class="headerlink" title="层次结构设计的基本原则"></a>层次结构设计的基本原则</h4><h5 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h5><img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/3.png" class>

<ul>
<li>解决方法：分层实现不同的功能</li>
</ul>
<h5 id="层次结构设计的例子"><a href="#层次结构设计的例子" class="headerlink" title="层次结构设计的例子"></a>层次结构设计的例子</h5><ol>
<li>网络应用数据（视频、文件、游戏）</li>
<li>数据可靠通信（数据错误、重复）</li>
<li>物理网络接入（光电等物理特性）</li>
</ol>
<h5 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h5><ol>
<li>各层之间是相互独立的</li>
<li>每一层要有足够的灵活性</li>
<li>各层之间完全解耦</li>
</ol>
<h4 id="计算网络的层次结构"><a href="#计算网络的层次结构" class="headerlink" title="计算网络的层次结构"></a>计算网络的层次结构</h4><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class>

<ul>
<li>OSI最终没有被市场所接受，最终并没有成为广泛使用的标准</li>
<li>OSI专家缺乏实际经验，一些功能在多层中重复出现</li>
<li>OSI标准制定周期过长，按OSI标准生产的设备无法及时进入市场</li>
</ul>
<h5 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h5><img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/TCP-IP%E6%A8%A1%E5%9E%8B.png" class>

<h3 id="现代互联网的网络拓扑"><a href="#现代互联网的网络拓扑" class="headerlink" title="现代互联网的网络拓扑"></a>现代互联网的网络拓扑</h3><h4 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h4><img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E2%80%94%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86%EF%BC%88%E5%AE%B6%E5%BA%AD%EF%BC%89.png" class>

<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E2%80%94%E2%80%94%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86%EF%BC%88%E4%BC%81%E4%B8%9A%EF%BC%89.png" class>



<h4 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h4><ul>
<li>各个ISP的互相连接</li>
</ul>
<h4 id="从用户角度看计算机网络"><a href="#从用户角度看计算机网络" class="headerlink" title="从用户角度看计算机网络"></a>从用户角度看计算机网络</h4><ul>
<li>客户-服务器（C/S）模式 </li>
<li>对等连接（P2P）模式</li>
</ul>
<h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><ul>
<li>速率单位：bps=bit/s</li>
</ul>
<h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><ul>
<li>发送时延：本地发出去所需要的时间<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E5%8F%91%E9%80%81%E6%97%B6%E5%BB%B6.png" class></li>
<li>传播时延：数据在线路中移动的速率<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6.png" class></li>
<li>排队时延：数据包在网络设备中等待被处理的时间</li>
<li>处理时延：数据包到达设备或者目的机器被处理所需要的时间</li>
</ul>
<h4 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h4><ul>
<li>RTT是评估网络质量的一项重要指标</li>
<li>RTT表示的是数据报文在端到端通信中的来回一次的时间</li>
</ul>
<h3 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h3><h4 id="物理层作用"><a href="#物理层作用" class="headerlink" title="物理层作用"></a>物理层作用</h4><ul>
<li>连接不同的物理设备</li>
<li>传输比特流</li>
</ul>
<h5 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h5><ul>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光纤</li>
<li>红外线</li>
<li>无线</li>
<li>激光</li>
<li>比特流<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E6%AF%94%E7%89%B9%E6%B5%81.png" class>

</li>
</ul>
<h4 id="信道的基本概念"><a href="#信道的基本概念" class="headerlink" title="信道的基本概念"></a>信道的基本概念</h4><ul>
<li>信道是往一个方向传送信息的媒体</li>
<li>一条通信电路包含一个接收信道和一个发送信道</li>
</ul>
<h5 id="信道的分类（解决了发送和接收的冲突）"><a href="#信道的分类（解决了发送和接收的冲突）" class="headerlink" title="信道的分类（解决了发送和接收的冲突）"></a>信道的分类（解决了发送和接收的冲突）</h5><ul>
<li>单工通信信道：只有一个方向（有线电视、无线收音机）</li>
<li>半双工通信信道：双方都可发送和接收信息，但不可同时</li>
<li>全双工通信信道：双方都可发送和接收信息</li>
</ul>
<h4 id="分用-复用技术"><a href="#分用-复用技术" class="headerlink" title="分用-复用技术"></a>分用-复用技术</h4><p>​    提高了信道利用率，使信道可以同时传输多个信号。</p>
<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E5%88%86%E7%94%A8-%E5%A4%8D%E7%94%A8.png" class>

<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
<h3 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul>
<li>“帧”是数据链路层数据的基本单位</li>
<li>发送端在网络层的一段数据前后添加特定标记形成“帧”</li>
<li>接受端根据前后特定标记识别出“帧”</li>
</ul>
<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png" class>

<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><ul>
<li>即是控制字符在帧数据中，但是要当做不存在的去处理</li>
<li>解决数据中出现控制字符</li>
<li><img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%931.png" class></li>
<li>解决方法<ul>
<li>添加转义字符</li>
<li><img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%932.png" class></li>
<li>数据中也出现转义字符<ul>
<li>在转移字符前面加转义字符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="差错监测"><a href="#差错监测" class="headerlink" title="差错监测"></a>差错监测</h4><ul>
<li>物理层只管传输比特流，无法控制是否出错</li>
<li>数据链路层负责起“差错监测”的工作</li>
</ul>
<h5 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h5><img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81.png" class>


<h5 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h5><ul>
<li>一种根据传输或保存的数据而产生固定位数校验码的方法</li>
<li>检测数据传输或者保存后可能出现的错误</li>
<li>生成的数字计算出来并且附加到数据后面</li>
<li>模“2”除法是二进制下的除法</li>
<li>与算术除法类似，但除法不借位，实际是“异或”操作</li>
<li>异或<ul>
<li>0 xor 0 = 0</li>
<li>0 xor 1 = 1</li>
<li>1 xor 0 = 1</li>
<li>1 xor 1 = 0</li>
</ul>
</li>
<li>CRC的错误检验能力与位串的阶数r有关</li>
<li>数据链路层只进行数据的检测，不进行纠正<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%991.png" class>
<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%992.png" class>
<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%993.png" class>

</li>
</ul>
<h3 id="最大传输单元MTU"><a href="#最大传输单元MTU" class="headerlink" title="最大传输单元MTU"></a>最大传输单元MTU</h3><ul>
<li>数据链路层的数据帧也不是无限大的</li>
<li>以太网MTU一般为1500字节<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E8%B7%AF%E5%BE%84MTU.png" class>

</li>
</ul>
<h3 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><ul>
<li>物理地址、硬件地址</li>
<li>每一个设备都拥有唯一的MAC地址</li>
<li>MAC地址共有48位，使用十六进制表示</li>
<li>命令：ipconfig /all（可查询电脑ip和MAC地址）</li>
<li>通用格式：30-B4-9E-ED-85-CS</li>
</ul>
<h4 id="以太网协议-1"><a href="#以太网协议-1" class="headerlink" title="以太网协议"></a>以太网协议</h4><ul>
<li>是一种使用广泛的局域网技术</li>
<li>一种应用于数据链路层的协议</li>
<li>使用以太网可以完成<strong><em>相邻设备</em></strong>的数据帧传输</li>
</ul>
<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" class>

<ul>
<li>数据帧的传输过程，MAC地址表上有目标MAC地址的记录<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%9A%84%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B.png" class></li>
<li>数据帧的传输过程，MAC地址表上无目标MAC地址的记录<img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E6%95%B0%E6%8D%AE%E5%B8%A7%E4%BC%A0%E8%BE%932.png" class>

</li>
</ul>
<h5 id="数据链路层的缺陷"><a href="#数据链路层的缺陷" class="headerlink" title="数据链路层的缺陷"></a>数据链路层的缺陷</h5><img src="/2020/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%A6%82%E8%BF%B0%E7%AF%87/%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8.png" class>

]]></content>
      <categories>
        <category>GUGU</category>
        <category>KOUKOU</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>博客</title>
    <url>/2020/05/19/%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="如何创建博客"><a href="#如何创建博客" class="headerlink" title="如何创建博客"></a>如何创建博客</h3><ol>
<li>hexo new 文件名</li>
<li>hexo clean 清理huancun</li>
<li>hexo g重新生成</li>
<li>hexo d上传github page<ol>
<li>安装插件 —— npm install hexo-deployer-git –save</li>
<li>hexo d上传</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>GUGU</category>
      </categories>
      <tags>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础</title>
    <url>/2020/05/12/js%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><p>​    是浅拷贝还是深拷贝?</p>
<p>​        首先，我们要说的是Object.assign的基本用法：</p>
<p>​        Object.assign(目标,数据1,数据2….);<u></u></p>
<a id="more"></a>

<p>​    示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj) <span class="comment">//&#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj1,obj2);</span><br><span class="line"><span class="built_in">console</span>.log(obj3) <span class="comment">//&#123;name: "zhangsan", age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>​    关于Object.assign是浅拷贝还是深拷贝的问题：     </p>
<p>​        <em>答：第一级属性深拷贝，从第二级属性开始就是浅拷贝。</em></p>
<p>​    示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1  一层深拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a: 1&#125;</span></span><br><span class="line">newObj.a=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;a:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2  二层浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a:1,b:&#123;name:"zhangsan"&#125;&#125;</span></span><br><span class="line">newObj.b.name=<span class="string">"lisi"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;a:1,b:&#123;name:"lisi"&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj); <span class="comment">//&#123;a:1,b:&#123;name:"lisi"&#125;&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>KOUKOU</category>
        <category>js</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>KOUKOU专属</tag>
      </tags>
  </entry>
</search>
